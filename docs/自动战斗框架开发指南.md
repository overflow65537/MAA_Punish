# 自动战斗框架开发指南（MPAcustom）

本文档面向在本仓库内开发/扩展**自动战斗**的脚本作者。当前框架由三部分构成：

- **框架层（动作与通用能力）**：`assets/MPAcustom/action/tool/CombatActions.py`
- **信息层（角色配置与素材索引）**：`assets/MPAcustom/action/tool/LoadSetting.py`（`ROLE_ACTIONS`）
- **业务层（每个角色/通用战斗逻辑）**：`assets/MPAcustom/action/exclusives/*.py`

除此之外，还有一个**必须的注册入口**：`assets/MPAcustom/agent_file.py`。所有要在 Pipeline 里通过 `custom_action` 调用到的类，都需要在这里注册。

---

## 1. 运行机制概览（从 Pipeline 到 Python）

自动战斗的真实执行链路（重要）：

- **Pipeline 节点触发**：Pipeline 的某个节点配置了 `"action": "Custom", "custom_action": "XXX"`
- **Agent 注册解析**：`assets/MPAcustom/main.py` 启动 Agent，导入 `agent_file.py`，将 `"XXX"` 映射到你实现的 `CustomAction` 子类
- **业务脚本编排动作**：你的角色脚本（`exclusives/XXX.py`）在 `run()` 内调用 `CombatActions` 提供的动作/识别方法
- **动作/识别落地**：`CombatActions` 内部通过 `context.run_action(...)` / `context.run_recognition(...)` 调用 Pipeline 中定义的动作/识别节点

你写的战斗逻辑本质上是：**在合适的时机，调用一组已存在的动作节点，并用识别节点做分支判断**。

---

## 2. 目录与关键文件

- **角色配置（信息层）**：`assets/MPAcustom/action/tool/LoadSetting.py`
  - `ROLE_ACTIONS`：角色名 → `cls_name`（业务类名）/ 模板 / 元信息
- **通用战斗对象（框架层）**：`assets/MPAcustom/action/tool/CombatActions.py`
  - 封装了攻击、闪避、技能、消球、QTE、状态识别、信号球决策等
- **角色脚本（业务层）**：`assets/MPAcustom/action/exclusives/*.py`
  - 每个文件一般对应一个 `cls_name`
- **CustomAction 注册表（必须）**：`assets/MPAcustom/agent_file.py`
  - `@AgentServer.custom_action("XXX")`
- **动作/识别节点定义（Pipeline）**：
  - 基础触控版：`assets/resource/base/pipeline/Auto_Battle/`
  - Win32 键盘版：`assets/resource/pgr_win32/pipeline/Auto_Battle_action.jsonc`

---

## 3. 新增角色：先改配置（LoadSetting.py）

在 `assets/MPAcustom/action/tool/LoadSetting.py` 的 `ROLE_ACTIONS` 中新增一项。

### 3.1 字段说明（建议完整填写）

- **键名（如 `"里·超刻"`）**：用于选人/OCR/识别的“正式名称”
- **`name`**：别名（部分场景 OCR 可能只识别出简称；`CombatActions(role_name=...)` 也会用它做匹配）
- **`type`**：`Attacker` / `Tank` / `Support`（用于选人权重/分类逻辑）
- **`cls_name`**：业务类名（必须，稍后要与 `exclusives` 文件 + `agent_file` 注册一致）
- **`metadata`**：用于选人权重计算（元素占比、代数等）
- **`template`**：选人界面识别头像模板（列表）
- **`attack_template`**：战斗内识别当前角色的攻击键模板（单个）
- **`skill_template`（可选）**：给 `Arrange_Signal_Balls()` 使用的信号球模板；没有它就不能走自动三消决策

### 3.2 例子（可直接拷贝改）

```python
ROLE_ACTIONS = {
    "里·超刻": {
        "name": "超刻",
        "type": "Attacker",
        "cls_name": "Hyperreal",
        "metadata": {"fire": 100, "generation": 2},
        "template": [
            "肉鸽通用/超刻.png",
            "肉鸽通用/超刻终解.png",
            "肉鸽通用/超刻_矩阵.png",
            "肉鸽通用/超刻终解_矩阵.png",
        ],
        "attack_template": "自定义战斗/超刻.png",
        "skill_template": {
            "red": {"识别信号球": {"template": ["信号球/超刻_红.png"]}},
            "blue": {"识别信号球": {"template": ["信号球/超刻_蓝.png"]}},
            "yellow": {"识别信号球": {"template": ["信号球/超刻_黄.png"]}},
        },
    },
}
```

---

## 4. 新增角色：实现业务逻辑（exclusives）

### 4.1 放置位置与命名规则

- **文件路径**：`assets/MPAcustom/action/exclusives/<cls_name>.py`
- **类名**：必须与 `<cls_name>` 完全一致
- **继承**：`class XXX(CustomAction):`
- **入口方法签名**：`run(self, context: Context, argv: CustomAction.RunArg) -> CustomAction.RunResult`

### 4.2 最小可用模板（推荐从这里起步）

```python
from MPAcustom.action.basics import CombatActions
from maa.context import Context
from maa.custom_action import CustomAction


class YourRole(CustomAction):
    def run(
        self, context: Context, argv: CustomAction.RunArg
    ) -> CustomAction.RunResult:
        action = CombatActions(context, role_name="你的角色名或别名")

        action.lens_lock()

        if action.check_Skill_energy_bar():
            action.use_skill(1000)
            action.auxiliary_machine()
            action.auto_qte("a")
        else:
            target = action.Arrange_Signal_Balls("any")
            action.ball_elimination_target(target)
            action.continuous_attack(6, 200)

        return CustomAction.RunResult(success=True)
```

### 4.3 业务脚本编写建议（稳定性优先）

- **避免“无限循环”**：建议使用“持续 X 秒/执行 N 次”的循环（参考 `exclusives/Shukra.py`）
- **所有动作都允许失败**：比如 `attack()` 会先识别 `"战斗中"`，不在战斗则直接返回 `False`；业务逻辑里尽量不要依赖单次动作必成功
- **节奏控制**：`time.sleep()` 是必要的（过快会导致识别滞后/动作丢失），但别睡太久导致错过窗口
- **状态判断尽量走识别节点**：把“是否可释放/是否进入某阶段”等条件抽成 Pipeline 识别节点，然后用 `check_status()` 统一判断

---

## 5. 必做步骤：在 agent_file.py 注册 CustomAction

如果你只写了 `exclusives/YourRole.py`，但没有注册，那么 Pipeline 里写 `custom_action: "YourRole"` 仍然会找不到实现。

在 `assets/MPAcustom/agent_file.py` 增加（并确保有 import）：

```python
from action.exclusives.YourRole import YourRole


@AgentServer.custom_action("YourRole")
class Agent_YourRole(YourRole):
    pass
```

约定：

- `@AgentServer.custom_action("...")` 里的字符串必须与 `ROLE_ACTIONS[*]["cls_name"]` 一致
- 也必须与业务类名一致（`class YourRole(...)`）

---

## 6. Pipeline 节点约定（CombatActions 依赖哪些名字）

`CombatActions` 并不“直接点击屏幕”，而是调用 Pipeline 里定义好的节点名。以下是常用依赖（你写业务脚本时要知道这些名字来自哪里）：

### 6.1 动作节点（action）

在 `assets/resource/base/pipeline/Auto_Battle/Auto_Battle_Action.jsonc`（触控版）与 `assets/resource/pgr_win32/pipeline/Auto_Battle_action.jsonc`（键盘版）中定义：

- `攻击` / `闪避` / `技能`
- `长按攻击(duration)` / `长按闪避(duration)` / `长按技能(duration)`
- `qte1` / `qte2`
- `消球1` ~ `消球8`
- `锁定视角`、`辅助机`（若你的逻辑用到了它们）

### 6.2 识别节点（recognition）

在 `assets/resource/base/pipeline/Auto_Battle/` 下（例如 `Check_Characters_Skill.jsonc`、`Auto_QTE.jsonc`）定义：

- `技能_能量条`：`check_Skill_energy_bar()`
- `统计信号球数量`：`count_signal_balls()`
- `检查血量百分比`：`get_hp_percent()`
- `检查红色QTE待激发` / `检查蓝色QTE待激发` / `检查黄色QTE待激发`：`auto_qte()`
- 角色/阶段特判（示例）：`检查残月值_终焉`（见 `exclusives/Oblivion.py`）

### 6.3 新增“状态判断”的正确姿势

当你想判断“是否进入某形态/是否有 buff/是否可派生”等：

- **先在 Pipeline 里新增一个识别节点**（找一个合适的 jsonc 文件放进去）
- 然后在业务脚本里调用：

```python
if action.check_status("你的识别节点名"):
    ...
```

`check_status(node, pipeline_override)` 也支持临时覆写 roi/template/threshold 等参数，适合做快速验证与调参。

---

## 7. CombatActions 常用 API 速查（框架层能力）

### 7.1 基础动作

- `lens_lock()`：锁定视角（对应动作节点 `锁定视角`）
- `attack()` / `continuous_attack(count=10, interval=100)`：普攻（带“是否在战斗中”的识别保护）
- `dodge()`：闪避
- `use_skill(duration=0)`：释放技能后可等待一段时间（毫秒）
- `auxiliary_machine()`：辅助机

### 7.2 长按与触控细节

- `long_press_attack(duration=1000)`
- `long_press_dodge(duration=1000)`
- `long_press_skill(time=1000)`：注意该函数参数名是 `time`（历史原因）
- `down_dodge(contact=0)` / `up_dodge(contact=0)`：按下/松开闪避（做“长闪/蓄力位移”类操作时可用）

### 7.3 信号球与数值

- `ball_elimination_target(target=2)`：点击消球位（1~8）。你可以把 `Arrange_Signal_Balls()` 的返回值直接传进来
- `Arrange_Signal_Balls(target_ball="any") -> int`：信号球决策（依赖 `ROLE_ACTIONS` 中的 `skill_template`）
- `count_signal_balls() -> int`：OCR 统计信号球数量
- `get_hp_percent() -> int`：血量百分比（0~100）

### 7.4 状态检查与 QTE

- `check_Skill_energy_bar() -> bool`：大招能量是否就绪
- `check_status(node: str, pipeline_override: dict = {})`：跑一次指定识别节点，命中则返回识别结果，否则返回 `False`
- `trigger_qte(target=1)`：点击 qte1/qte2
- `auto_qte(target="a")`：`a` 表示依次尝试 `r/b/y` 三色

### 7.5 换人/切换角色（`Switch()`）

`Switch()` 是一个**基于 QTE 颜色**的“自动换人”辅助方法，主要做两件事：

- **按角色类型切换**：读取 `ROLE_ACTIONS[self.role_name]["type"]`，并根据 `Attacker/Tank/Support` 去点击对应颜色的“切换 QTE”
- **通用轮换切换**：当 `role_name` 在 `ROLE_ACTIONS` 中找不到时，进入 `general` 模式，通过 `QTE目标` 节点里写入的 `post_delay` 在 `1/2` 之间交替点击 `qte1/qte2`

核心目的（多人队伍轮切输出）：

- `Switch()` 的主要设计场景是**多人/多角色队伍的轮切输出**：通过换人把“当前角色的空窗期”转移给队伍中的其他角色，从而提升整体输出与稳定性
- 当前实现遵循一个固定的轮换方向（循环）：**进攻（Attacker）→ 辅助（Support）→ 装甲（Tank）→ 进攻（Attacker）→ ...**
  - `Attacker`：尝试点击 `切换蓝色QTE`（切到辅助）
  - `Support`：尝试点击 `切换黄色QTE`（切到装甲）
  - `Tank`：尝试点击 `切换红色QTE`（切回进攻）

依赖与约定（缺一不可）：

- **依赖识别节点**（在 `assets/resource/base/pipeline/Auto_Battle/Auto_QTE.jsonc`）：
  - `切换蓝色QTE` / `切换红色QTE` / `切换黄色QTE`：用于定位“换人用的 QTE 入口区域”，命中后由代码直接 `post_click()` 点击其坐标
  - `QTE目标`：仅用于存放一个标记值（`post_delay` 字段被当成 `1/2` 的轮换状态）
- **依赖 `识别人物` 节点**（在 `assets/resource/base/pipeline/Auto_Battle/Auto_Battle.jsonc`）：
  - `Switch()` 末尾会执行 `context.override_pipeline({"识别人物": {"enabled": True}})`，重新启用战斗中角色识别（`RecognitionRole`），让后续战斗逻辑能跟随当前角色切换

行为细节（写脚本时建议了解）：

- `Attacker/Tank/Support` 三种类型分别尝试点击 `切换蓝/红/黄` 的 QTE；命中后会进入一个最多 100 次的循环：不断截屏→再次识别→普攻→若仍命中则继续点击，直到识别不到为止
- `general` 模式不做颜色识别，而是**在 `qte1/qte2` 之间轮换点击**，并把下一次目标写回 `QTE目标.post_delay`

#### 7.5.1 业务脚本中的真实案例（如何用、为什么用）

说明：当前 `assets/MPAcustom/action/exclusives/` 里**显式调用** `Switch()` 的脚本主要是以下两类用法（其余角色脚本更多是 `auto_qte()`/`trigger_qte()`，未直接调用 `Switch()`）。

- **案例 A：通用战斗的“轮换换人”**（`exclusives/GeneralFight.py`）
  - **触发时机**：打一套通用动作之后（锁视角→普攻→消球→技能→连打→辅助机），直接调用 `Switch()`
  - **为什么能轮换**：`role_name="通用"` 不在 `ROLE_ACTIONS` 中，`Switch()` 会进入 `general` 模式，读取 `QTE目标.post_delay`（默认 1），在 `qte1/qte2` 之间交替点，并把下一次目标写回 `QTE目标`
  - **适用场景**：不关心“切到谁”，只想让队伍轮换维持输出/触发 QTE 机制；也适合作为调试用的“换人链路是否正常”验证脚本

- **案例 B：角色打完爆发后“按职业类型切人”**（`exclusives/CrimsonWeave.py`）
  - **触发时机**：囚影在“登龙/爆发 + 一轮消球”后调用 `Switch()`（两个分支末尾都这样做）
  - **会切到谁**：囚影在 `ROLE_ACTIONS` 中 `type` 是 `Attacker`，因此 `Switch()` 会尝试点击 `切换蓝色QTE`（代码注释里写的是“切换到辅助角色”）
  - **适用场景**：主 C 打完一套后让位给辅助/装甲去挂 debuff、补 buff 或承伤；你只需要保证 `ROLE_ACTIONS` 的 `type` 正确即可

#### 7.5.2 使用建议（从案例抽象出来的写法）

- **建议 1：把 `Switch()` 放在“阶段结束点/空窗期”**：它更适合在“角色打完一整套后的空窗期”使用（例如爆发收尾、长按动作结束、消球收尾之后；参考 `CrimsonWeave.py`），用来规避当前角色的空窗，把输出窗口交给下一位角色
- **建议 2：通用轮换要先准备 `QTE目标`**：`general` 模式依赖 `Auto_QTE.jsonc` 里的 `QTE目标.post_delay` 做轮换标记；如果你在自定义 pipeline 中移除了该节点，`Switch()` 会直接报错并返回
- **建议 3：切完记得让识别跟上**：`Switch()` 会自动重新启用 `识别人物`；如果你在脚本里手动禁用了识别节点（`override_pipeline({"识别人物": {"enabled": False}})`），要注意与 `Switch()` 的行为不要冲突

稳定性说明（为什么通常不会“卡动作”）：

- `Switch()` 在识别到“切换 QTE”后，会**持续检查直到切换完毕才退出**（或到达内部循环上限），因此一般不需要你额外加“等待切换完成”的逻辑
- 每次循环检测都会调用一次 `attack()`（普攻），用于维持输出/节奏，因此通常**不用担心换人检测导致完全停手**（当然，具体收益仍取决于当前角色/关卡机制）

---

## 8. 调试与常见问题

### 8.1 最常见的“写了脚本但不生效”

- **忘了注册**：没在 `assets/MPAcustom/agent_file.py` 添加 `@AgentServer.custom_action("YourRole")`
- **名字不一致**：`ROLE_ACTIONS[*]["cls_name"]` ≠ 业务类名 ≠ `custom_action` 字符串
- **模板路径不对**：`template/attack_template/skill_template` 指向了不存在的图片（或平台资源不一致）

### 8.2 信号球相关问题

- `Arrange_Signal_Balls()` 报“模板未加载”：说明当前 `CombatActions(role_name=...)` 没匹配到 `ROLE_ACTIONS` 的 `skill_template`
  - 检查你传的 `role_name` 是否是 `ROLE_ACTIONS` 的键名或 `name` 别名
  - 或者该角色配置里确实没填 `skill_template`

### 8.3 识别节点调参建议

- 先用 `check_status("节点名", pipeline_override=...)` 在代码里临时覆盖 `roi/threshold/template` 验证效果
- 稳定后再把参数固化回对应的 `assets/resource/**/pipeline/*.jsonc`

---

## 9. 参考实现（直接抄结构）

- `assets/MPAcustom/action/exclusives/GeneralFight.py`：通用战斗最小示例
- `assets/MPAcustom/action/exclusives/Oblivion.py`：状态节点分支（`check_status()`）的典型写法
- `assets/MPAcustom/action/exclusives/Shukra.py`：信号球决策 + 限时循环的典型写法
