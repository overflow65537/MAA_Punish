# 自动战斗框架开发指南

## 1. 开发环境准备

### 1.1 基本要求

- 具备基础的Python编程知识
- 熟悉[MaaFW](https://github.com/MaaAssistantArknights/MaaFramework/blob/main/docs/zh_cn/1.1-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.md)的基本功能

## 2. 添加新角色配置

### 2.1 在 setting.json 中添加角色

在 `assets/custom/action/Loadsetting.py` 中的 `ROLE_ACTIONS` 变量中添加新角色配置：

```python
{
        "里·超刻": {
        # 部分场景下会识别这个名字
        "name": "超刻",
        # 自动战斗的动作名
        "cls_name": "Hyperreal",
        "metadata": {  # 角色的属性
            "fire": 100,
            # 代数
            "generation": 2,
        },
        # 角色头像模板
        "template": [
            "肉鸽通用/超刻.png",
            "肉鸽通用/超刻终解.png",
            "肉鸽通用/超刻_矩阵.png",
            "肉鸽通用/超刻终解_矩阵.png",
        ],
        # 角色攻击按键模板,用来在战斗内识别角色
        "attack_template": "自定义战斗/超刻.png",
        # 角色技能模板,用来自动释放三消
        "skill_template": {
            "red": {"识别信号球": {"template": ["信号球/超刻_红.png"]}},
            "blue": {"识别信号球": {"template": ["信号球/超刻_蓝.png"]}},
            "yellow": {"识别信号球": {"template": ["信号球/超刻_黄.png"]}},
        },
    }
}
```

配置说明：

- `键名`：在`ROLE_ACTIONS`中用于标识该角色的唯一字符串，例如：`里·超刻`
- `name`：游戏中显示的角色其他名字，例如：`终焉`、`深痕`
- `cls_name`：对应的Python类名，例如：`Oblivion`、`Stigmata`
- `metadata`：角色的属性：
  - `fire`/`ice`/`lightning`/`dark`/`nihil`/`physical`：角色的元素属性值和他们针对总输出的比例，例如："fire":100代表火元素输出100%
  - `generation`：角色的代数，例如：2,也可以手动增加这个数值来调整角色的权重
- `template`：角色头像模板，用于在选人内识别角色，例如：`肉鸽通用/超刻.png`
- `attack_template`：角色攻击按键模板，用来在战斗内识别角色，例如：`自定义战斗/超刻.png`
- `skill_template`：角色技能模板，用来自动释放三消技能,如果为空,则自动消球方法无法使用

### 2.2 创建角色战斗类文件

在 `assets/custom/action/exclusives/` 目录下创建新的Python文件，文件名与战斗类名称相同。

## 3. 角色战斗类开发

### 3.1 基础结构

每个角色战斗类都需要继承CustomAction并实现必要的方法：
开头：

```python
from custom.action.basics import CombatActions # 导入基础战斗类,其中包含了各种动作
from maa.context import Context
from maa.custom_action import CustomAction


class GeneralFight(CustomAction):
    def run(
        self, context: Context, argv: CustomAction.RunArg
    ) -> CustomAction.RunResult:
        action = CombatActions(context,role_name="通用") # 初始化战斗类,传入上下文对象

```

## 4. 核心战斗方法

### 4.1 基础动作

#### `lens_lock`

镜头锁定

#### `attack`

攻击

#### `dodge`

闪避

#### `use_skill`

使用技能

#### `auxiliary_machine`

辅助机

### 4.2 长按动作

#### `long_press_attack`

长按攻击
该方法需要传入部分参数:

- `time`: *int*
  长按时间，单位为毫秒，默认1000。

#### `long_press_dodge`

长按闪避
该方法需要传入部分参数:

- `time`: *int*
  长按时间，单位为毫秒，默认1000。

#### `long_press_skill`

长按大招
该方法需要传入部分参数:

- `time`: *int*
  长按时间，单位为毫秒，默认1000。

## 5. 高级操作

### 5.1 状态检查

#### `check_status`

检查状态
检测成功时返回识别结果，否则返回False
该方法需要传入部分参数:

- `node`: *string*
  MaaFW中Pipeline节点，方法会运行一次node来检查条件是否命中，需要自行编写。

- `pipeline_override`: *dict*
  覆盖Pipeline节点，默认为空。

#### `check_Skill_energy_bar`

检查大招能量
当大招能量足够释放大招时，返回True，否则返回False
该方法需要传入部分参数:

### 5.2 信号球操作

#### `ball_elimination_target`

指定消球位置
该方法需要传入部分参数:

- `target`: *int*(1|2|3|4|5|6|7|8)
  消球位置，默认为2。

#### `Arrange_Signal_Balls`

识别三消位置
成功发现目标时候返回正数，如果发现可以组成三消的目标则返回负数，否则返回0
该方法需要传入部分参数:

- `target_ball`: *string*(red|blue|yellow|any)
  目标颜色
- `template`: *dict*
  包含红/蓝/黄球识别模板路径的pipeline_override字典
  例如:

```json
{
"red": {"识别信号球": {"template": ["信号球/启明_红.png"]}},
"blue": {"识别信号球": {"template": ["信号球/启明_蓝.png"]}},
"yellow": {"识别信号球": {"template": ["信号球/启明_黄.png"]}}
}
```

### 5.3 QTE和换人

#### `trigger_qte`

触发QTE/换人
该方法需要传入部分参数:

- `target`: *int*(1|2)
  QTE位置，默认为1。

## 6. 使用示例

### 6.1 基础战斗流程

```python
class GeneralFight(CustomAction):
    def run(
        self, context: Context, argv: CustomAction.RunArg
    ) -> CustomAction.RunResult:
        action = CombatActions(context,role_name="通用")

        action.lens_lock()
        if action.check_Skill_energy_bar():
            action.logger.info("大招就绪")
            action.use_skill()
        else:
            action.ball_elimination_target()
            action.continuous_attack(4,300)
        return CustomAction.RunResult(success=True)

```

### 6.2 信号球处理示例

```python
class Shukra(CustomAction):
# 启明战斗逻辑
    tempelate = {
        "red": {"识别信号球": {"template": ["信号球/启明_红.png"]}},
        "blue": {"识别信号球": {"template": ["信号球/启明_蓝.png"]}},
        "yellow": {"识别信号球": {"template": ["信号球/启明_黄.png"]}},
    }

    def run(
        self, context: Context, argv: CustomAction.RunArg
    ) -> CustomAction.RunResult:

        actions = CombatActions(context,role_name="启明",template= self.tempelate)

        actions.lens_lock()

        if actions.check_Skill_energy_bar():
            actions.use_skill()  # 万世生死,淬于寒冰
            start_time = time.time()
            while time.time() - start_time < 3:  # 生死喧嚣,归于寂静
                time.sleep(0.1)
                actions.ball_elimination_target(1)

        elif actions.check_status("检查信号球数量_启明"):  # 信号球数量大于9
            start_time = time.time()
            while time.time() - start_time < 7:
                time.sleep(0.3)
                target = actions.Arrange_Signal_Balls("any")
                actions.ball_elimination_target(target)
                actions.logger.info(f"初次消球")
                if target > 0:
                    time.sleep(0.1)
                    actions.logger.info(f"三连目标,开始二次消球")
                    actions.ball_elimination_target(1)  # 单独消球
                elif target == 0:
                    actions.logger.info(f"信号球空,结束")
                    break
            actions.logger.info(f"长按攻击")
            actions.long_press_attack()
        else:
            actions.logger.info(f"普攻")
            start_time = time.time()
            while time.time() - start_time < 2:
                actions.attack()  # 攻击
                time.sleep(0.1)
        return CustomAction.RunResult(success=True)
```

### 6.3 高级战斗流程参考

可以参考现有角色的实现：

- `Oblivion.py`：终焉的基础战斗流程
- `Stigmata.py`：深痕的状态管理
- `LostLullaby.py`：深谣的复杂连招
- `Shukra.py`：启明的信号球处理

## 7. 注意事项

1. 确保角色名称与游戏中完全一致
2. 战斗类名称使用英文，建议有意义且易识别
3. 合理控制动作间隔，避免操作过快或过慢
4. 做好异常处理，确保战斗流程稳定
5. 及时更新状态检查条件，适应游戏版本变化
6. 定期测试和优化战斗逻辑
7. 保持代码的可维护性和可读性
